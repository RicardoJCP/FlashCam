/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package pt.flash.cam.android;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiC;
import org.appcelerator.titanium.util.Log;
import org.appcelerator.titanium.util.TiConfig;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.view.TiCompositeLayout;
import org.appcelerator.titanium.view.TiCompositeLayout.LayoutArrangement;
import org.appcelerator.titanium.view.TiUIView;

import android.Manifest;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.graphics.Rect;
import android.hardware.Camera;
import android.hardware.Camera.CameraInfo;
import android.hardware.Camera.AutoFocusCallback;
import android.hardware.Camera.Parameters;
import android.hardware.Camera.PictureCallback;
import android.media.CamcorderProfile;
import android.media.ExifInterface;
import android.media.MediaRecorder;
import android.net.Uri;
import android.os.Environment;
import android.provider.MediaStore;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.FrameLayout;

// This proxy can be created by calling FlashCamAndroid.createExample({message: "hello world"})
@Kroll.proxy(creatableInModule = FlashCamAndroidModule.class)
public class ExampleProxy extends TiViewProxy {
	// Standard Debugging variables
	private static final String LCAT = "ExampleProxy";
	private static final boolean DBG = TiConfig.LOGD;
	private static String SAVE = "camera";

	public SurfaceHolder wrap = null;
	
	static final int REQUEST_VIDEO_CAPTURE = 0;
	
//	private void dispatchTakeVideoIntent() {
	//    Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
	    //if (takeVideoIntent.resolveActivity(getPackageManager()) != null) startActivityForResult(takeVideoIntent, REQUEST_VIDEO_CAPTURE);
	//}

	public static void setCameraDisplayOrientation(Activity activity, android.hardware.Camera camera) {

		android.hardware.Camera.CameraInfo info = new android.hardware.Camera.CameraInfo();
		android.hardware.Camera.getCameraInfo(0, info);

		int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
		int degrees = 0;
		switch (rotation) {
		case Surface.ROTATION_0:
			degrees = 0;
			break;
		case Surface.ROTATION_90:
			degrees = 90;
			break;
		case Surface.ROTATION_180:
			degrees = 180;
			break;
		case Surface.ROTATION_270:
			degrees = 270;
			break;
		}

		camera.setDisplayOrientation((info.orientation - degrees + 360) % 360);
	}

	public class CameraView extends TiUIView implements SurfaceHolder.Callback {

		@Kroll.method
		public void testInside(String message) {
			Log.d("MODULE", "Tried setting module message to: " + message);
		}
		
		private Camera camera;
		
		private boolean isAutoFocusSupported() {
			Camera cam = ((CameraView) view).currentCameraInstance();
			List<String> supportedFocusModes = cam.getParameters().getSupportedFocusModes();
			return supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);//FOCUS_MODE_AUTO
		}

		public CameraView(TiViewProxy proxy) {
			super(proxy);

			Log.i("VIEW","CAMERA VIEW: "+REQUEST_VIDEO_CAPTURE);
			
			SurfaceView preview = new SurfaceView(proxy.getActivity());
			SurfaceHolder previewHolder = preview.getHolder();
			previewHolder.addCallback(this);
			previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

			FrameLayout previewLayout = new FrameLayout(proxy.getActivity());
			previewLayout.addView(preview, layoutParams);

			setNativeView(previewLayout);
		}

		public Camera currentCameraInstance() {
			return this.camera;
		}
		
		@Override
		public void processProperties(KrollDict d) {
			super.processProperties(d);
		}

		@Override
		public void surfaceChanged(SurfaceHolder previewHolder, int format,
				int width, int height) {

			setCameraDisplayOrientation(act, camera);

			Log.i("CAMERA", "Starting Preview: "+REQUEST_VIDEO_CAPTURE);
			camera.startPreview();
		}

		@Override
		public void surfaceCreated(SurfaceHolder previewHolder) {
			// TODO Auto-generated method stub
			Log.i("CAMERA", "Opening Camera: "+REQUEST_VIDEO_CAPTURE);
			try {
				
				this.camera = getCameraInstance();

				if (this.camera == null) {
					Log.e("CAMERA","Camera is null. Make sure \n\t<uses-permission android:name=\"android.permission.CAMERA\" />\nis in you tiapp.xml file.");
					throw new Exception();
				}

				Log.i("CAMERA", "Setting Preview Display");
				
				wrap = previewHolder;
				
				camera.setPreviewDisplay(previewHolder);

				setCameraDisplayOrientation(act, camera);

				Parameters cameraParams = camera.getParameters();

				boolean hasFlash = true;

				if(cameraParams.getFlashMode() == null) hasFlash = false;

				List<String> supportedFlashModes = cameraParams.getSupportedFlashModes();
				if(supportedFlashModes == null	|| supportedFlashModes.isEmpty() || supportedFlashModes.size() == 1 && supportedFlashModes.get(0).equals(Camera.Parameters.FLASH_MODE_OFF)) hasFlash = false;

				if(isAutoFocusSupported()) {
					Log.i("CAMERA", "Auto Focus is Supported");
					cameraParams.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);//FOCUS_MODE_AUTO
				}
				
				if(hasFlash) cameraParams.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);

				camera.setParameters(cameraParams);
				
			} catch (IOException e) {
				
				e.printStackTrace();
			} catch (Exception e) {
				
				e.printStackTrace();
			}
		}

		@Override
		public void surfaceDestroyed(SurfaceHolder arg0) {
			// TODO Auto-generated method stub

			Parameters cameraParams = camera.getParameters();

			cameraParams.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);

			camera.setParameters(cameraParams);

			camera.release();
			camera = null;
		}

		public Camera getCameraInstance() {
			Camera c = null;
			try {
				Log.i("CAMERA", "Using Back Camera");
				c = Camera.open();
			} catch (Exception e) {
				Log.d("CAMERA", "Camera not available");
			}
			return c;
		}
	}

	private TiUIView view = null;
	private Activity act = null;

	// Constructor
	public ExampleProxy() {
		super();
	}

	@Override
	public TiUIView createView(Activity activity) {
		view = new CameraView(this);
		act = activity;
		

	//	int permissionCheck = ContextCompat.checkSelfPermission(act,Manifest.permission.CAMERA);
		Log.i("PERMISSIONS","CHECK");
		if (ContextCompat.checkSelfPermission(activity,Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
			Log.i("PERMISSIONS","SHOULD");
		    if(ActivityCompat.shouldShowRequestPermissionRationale(activity,Manifest.permission.CAMERA)) {
		    	Log.i("PERMISSIONS","SHOW");
		    }
		    else {
		    	Log.i("PERMISSIONS","REQUEST");
		        ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.CAMERA},REQUEST_VIDEO_CAPTURE);
		    }
		}
		
		view.getLayoutParams().autoFillsHeight = true;
		view.getLayoutParams().autoFillsWidth = true;
		return view;
	}
	
	public void onRequestPermissionsResult(int requestCode,String permissions[], int[] grantResults) {
	    switch (requestCode) {
	        case REQUEST_VIDEO_CAPTURE: {
	            if(grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {

	            	Log.i("PERMISSIONS","DONE");

	            }
	            return;
	        }
	    }
	}

	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options)
	{
		super.handleCreationDict(options);
		
		if (options.containsKey("save_location")) {
			SAVE = options.getString("save_location");
		}
	}
	
	@Kroll.method
	public void setSaveLocation(String location)
	{
		SAVE = location;
	}
	
	@Kroll.method
	public void takePhoto()
	{
		Log.i("CALL","TAKE PHOTO");
		
		Camera cam = ((CameraView) view).currentCameraInstance();
		
		if( isAutoFocusSupported() ) {
			cam.autoFocus(mAutoFocusCallback);
		} else {
			cam.takePicture(null, null, mPicture);
		}
	}
	
	private MediaRecorder mMediaRecorder = new MediaRecorder();
	
	@Kroll.method
	public void takeVideo() throws IOException
	{
	    
		Log.i("CALL","RECORD VIDEO");
	    
		Log.i("PERMISSIONS","VIDEO: "+REQUEST_VIDEO_CAPTURE);
		
		Camera cam = ((CameraView) view).currentCameraInstance();
		 
		try {
			
			cam.lock();
		}
	    catch(IllegalStateException e) {}
	    catch(Exception e) {}
	 
		try { 
			
			cam.unlock();
		}
	    catch(IllegalStateException e) {}
	    catch(Exception e) {}
		
	    mMediaRecorder.setCamera(cam);

	    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);
	    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.DEFAULT);
	    
	    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);
	    
	    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
	    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT);
	    
	    mMediaRecorder.setMaxDuration(300000);
	    
	    mMediaRecorder.setOutputFile(android.os.Environment.getExternalStorageDirectory().getAbsolutePath()+"/Video_" + System.currentTimeMillis() + ".mp4");

	    try {

		    mMediaRecorder.prepare();
	    	mMediaRecorder.start();
	    }
	    catch(IllegalStateException e) {}
	    catch(Exception e) {}
	}
	
	@Kroll.method
	public void stopVideo() {
		
		Log.i("CALL","STOP VIDEO");
		
		try {
			
			mMediaRecorder.stop();
		    mMediaRecorder.release();
		    mMediaRecorder = null;
		    
		} catch (Exception e) {
			
	        e.printStackTrace();  
	    } 
	}
	
	@Kroll.method
	public void permission( String method ) {
		
		Log.i("CALL","PERMISSION FOR "+method+" = "+REQUEST_VIDEO_CAPTURE);
	}
	
	private void triggerEvent( String path )
	{
		KrollDict imagePath = new KrollDict();
		
		File extFile = new File(path);
		Uri uriPath = Uri.fromFile(extFile);
		imagePath.put("media", uriPath.toString());

		fireEvent("success", imagePath);
	}
	
	private void rotatePicture( String path ){

		try {
			ExifInterface ei = new ExifInterface(path);
			
			int picture_orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
			int device_orientation = act.getWindowManager().getDefaultDisplay().getOrientation();
			
			doRotation(path,90);
			
		} catch (IOException e) {
			
			e.printStackTrace();
		}	
	}
	
	private void doRotation( String path, float rotate ){

		BitmapFactory bFactory = new BitmapFactory();
		Bitmap bmap = bFactory.decodeFile(path);
		
		Matrix matrix = new Matrix();
		matrix.setRotate(rotate, bmap.getWidth()/2, bmap.getHeight()/2);
		
		Bitmap rotated = Bitmap.createBitmap(bmap, 0, 0, bmap.getWidth(), bmap.getHeight(), matrix, true);
		
		File rotatedFile = new File(path);
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		rotated.compress(CompressFormat.JPEG, 80, bos);
		byte[] bitmapData = bos.toByteArray();
		
		try{
			FileOutputStream fos = new FileOutputStream(rotatedFile);
			fos.write(bitmapData);
			fos.close();
		} catch (FileNotFoundException e){
			Log.i("CAMERA", "File Not Found: "+e);
		} catch (IOException e){
			Log.i("CAMERA", "IO Error: "+e);
		}
	}
	
	private AutoFocusCallback mAutoFocusCallback = new AutoFocusCallback()
	{

		@Override
		public void onAutoFocus(boolean arg0, Camera camera) {

			camera.takePicture(null, null, mPicture);
		}
		
	};
	
	private PictureCallback mPicture = new PictureCallback()
	{

		@Override
		public void onPictureTaken(byte[] data, Camera c) {

			Log.i("CAMERA", "On Picture Taken");
			File pictureFile = getOutputMediaFile();
			
			if( pictureFile == null ) return;
			
			try{
				FileOutputStream fos = new FileOutputStream(pictureFile);
				fos.write(data);
				fos.close();

				rotatePicture(pictureFile.getPath());
				
				triggerEvent(pictureFile.getPath());
				
				if (1000 >= 0) {
					final Camera cam = c;
					new android.os.Handler().postDelayed(
					    new Runnable() {
					        public void run() {
					            Log.i("tag", "This'll run 300 milliseconds later");
					            if (((CameraView) view).currentCameraInstance() != null) {
					            	cam.startPreview();
					            }
					        }
					    }, 1000);
				}
			} catch (FileNotFoundException e){
				Log.i("CAMERA", "File Not Found: "+e);
			} catch (IOException e){
				Log.i("CAMERA", "IO Error: "+e);
			}
		}
		
	};
	
	private static File getOutputMediaFile(){
		
		File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),SAVE);
		
		if( !mediaStorageDir.exists() && !mediaStorageDir.mkdirs()) return null;
		
		String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
		
		File mediaFile;
		mediaFile = new File(mediaStorageDir.getPath() + File.separator + "IMG_" + timestamp + ".jpg");
		return mediaFile;
	}

	private boolean hasFlash(){
		Camera cam = ((CameraView) view).currentCameraInstance();
		Parameters params = cam.getParameters();
	    List<String> flashModes = params.getSupportedFlashModes();
	    if(flashModes == null) return false;
	    
	    for(String flashMode : flashModes) if(Parameters.FLASH_MODE_ON.equals(flashMode)) return true;

	    return false;
	}
	
	private boolean isAutoFocusSupported() {
		Camera cam = ((CameraView) view).currentCameraInstance();
		List<String> supportedFocusModes = cam.getParameters().getSupportedFocusModes();
		return supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
	}

	@Kroll.method
	public void printMessage(String message)
	{
		Log.d("CAM", "printing message: " + message);
	}


	@Kroll.getProperty @Kroll.method
	public String getMessage()
	{
        return "Hello World from my module";
	}

	@Kroll.setProperty @Kroll.method
	public void setMessage(String message)
	{
	    Log.d("CAM", "Tried setting module message to: " + message);
	}
}